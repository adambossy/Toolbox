#!/usr/bin/env bash
set -euo pipefail

# dot-sync: sync dotfiles between $HOME and this repo, with confirm-before-overwrite.
# Tracks:
#   ~/.vimrc
#   ~/.bashrc
#   ~/.gitconfig
#   ~/.local/bin/{git-ai-commit,git-clean-local-branches,git-clean-rebase}

# -------------------------------------------------------------------
# Repo dir = directory containing this script
# -------------------------------------------------------------------
if [[ -z "${DOTSYNC_REPO:-}" ]]; then
  DOTSYNC_REPO="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
  export DOTSYNC_REPO
fi
HOME_DIR="$HOME"
REPO_DIR="$DOTSYNC_REPO"

FILES=(
  ".vimrc"
  ".bashrc"
  ".gitconfig"
  ".sdirs"
  ".local/bin/git-ai-commit"
  ".local/bin/git-clean-local-branches"
  ".local/bin/git-clean-rebase"
  ".local/bin/convert-heics-to-jpgs"
  "Library/Application Support/Amethyst/Layouts/centered-primary-columns.js"
  "Library/Application Support/Amethyst/Layouts/centered-twin-columns.js"
)

usage() {
  cat <<EOF
dot-sync — sync a handful of dotfiles between \$HOME and this git repo.

Usage:
  dot-sync status|diff    Show differences (repo vs local)
  dot-sync pull           Copy repo -> local (confirm before overwrite; backup if changed)
  dot-sync push           Copy local -> repo (confirm before overwrite; backup if changed), then git-ai-commit + git push
EOF
}

# -------------------------------------------------------------------
# Helpers
# -------------------------------------------------------------------
log()  { printf "[dot-sync] %s\n" "$*"; }
warn() { printf "[dot-sync:WARN] %s\n" "$*" >&2; }

have_colordiff=false
command -v colordiff >/dev/null 2>&1 && have_colordiff=true

show_diff() {
  # $1 = old (dest), $2 = new (src)
  if [[ -e "$1" ]]; then
    if $have_colordiff; then colordiff -u "$1" "$2" || true
    else diff -u "$1" "$2" || true
    fi
  else
    echo "--- $1 (missing)"
    echo "+++ $2"
    if $have_colordiff; then colordiff -u /dev/null "$2" || true
    else diff -u /dev/null "$2" || true
    fi
  fi
}

backup_if_changed() {
  # $1 = path to back up
  local target="$1"
  if [[ -e "$target" ]]; then
    local ts; ts="$(date +%Y%m%d-%H%M%S)"
    cp -p "$target" "${target}.bak.${ts}"
    log "Backed up: $target -> ${target}.bak.${ts}"
  fi
}

ensure_parent() { mkdir -p "$(dirname "$1")"; }

# Parse entry that may be either a simple relative path or a mapping in the
# form: "local_path => repo_path". Prints "local|repo".
split_entry() {
  local entry="$1"
  local local_rel repo_rel
  if [[ "$entry" == *"=>"* ]]; then
    local_rel="${entry%%=>*}"
    repo_rel="${entry#*=>}"
  else
    local_rel="$entry"
    # Implicit mapping: always map repo path to the basename of the local path
    repo_rel="${local_rel##*/}"
  fi
  # trim leading/trailing whitespace on both sides
  local_rel="${local_rel#${local_rel%%[![:space:]]*}}"
  local_rel="${local_rel%${local_rel##*[![:space:]]}}"
  repo_rel="${repo_rel#${repo_rel%%[![:space:]]*}}"
  repo_rel="${repo_rel%${repo_rel##*[![:space:]]}}"
  printf '%s|%s' "$local_rel" "$repo_rel"
}

confirm_overwrite() {
  # $1 = dest path, $2 = src path, $3 = label (for display)
  local dest="$1" src="$2" label="$3"
  if [[ -e "$dest" ]] && ! cmp -s "$dest" "$src"; then
    echo "=== DIFF for $label ==="
    show_diff "$dest" "$src"
    read -r -p "Overwrite $dest with $src ? [y/N] " ans
    case "${ans:-}" in
      y|Y|yes|YES) return 0 ;;
      *) echo "Skipped: $label"; return 1 ;;
    esac
  fi
  # If dest doesn't exist or files are identical, no prompt needed
  return 0
}

copy_with_confirm() {
  # $1 = src, $2 = dest, $3 = label (e.g., .bashrc), $4 = post_copy_chmod (optional mode or empty)
  local src="$1" dest="$2" label="$3" mode="${4:-}"
  ensure_parent "$dest"

  # If identical, do nothing.
  if [[ -e "$dest" ]] && cmp -s "$dest" "$src"; then
    log "No change: $label"
    return 0
  fi

  # Confirm if we're about to overwrite an existing, different file
  if ! confirm_overwrite "$dest" "$src" "$label"; then
    return 0
  fi

  # Make backup (only if dest exists and differs or exists at all)
  [[ -e "$dest" ]] && backup_if_changed "$dest"

  # Copy and optionally chmod
  cp -fp "$src" "$dest"
  [[ -n "$mode" ]] && chmod "$mode" "$dest" || true
  log "Copied: $label"
}

copy_repo_to_local() {
  local entry="$1"
  local pair; pair="$(split_entry "$entry")"
  local local_rel="${pair%%|*}" repo_rel="${pair##*|}"
  local src="$REPO_DIR/$repo_rel" dst="$HOME_DIR/$local_rel"
  [[ -e "$src" ]] || { log "Repo missing $repo_rel (skip)"; return; }
  # Executables in .local/bin get +x when copying to local
  local mode=""
  [[ "$local_rel" == .local/bin/* ]] && mode="0755"
  copy_with_confirm "$src" "$dst" "Repo → Local: $local_rel" "$mode"
}

copy_local_to_repo() {
  local entry="$1"
  local pair; pair="$(split_entry "$entry")"
  local local_rel="${pair%%|*}" repo_rel="${pair##*|}"
  local src="$HOME_DIR/$local_rel" dst="$REPO_DIR/$repo_rel"
  [[ -e "$src" ]] || { log "Local missing $local_rel (skip)"; return; }
  # Preserve exec bit when syncing into repo for local executables
  local mode=""
  if [[ "$local_rel" == .local/bin/* && -x "$src" ]]; then mode="0755"; fi
  copy_with_confirm "$src" "$dst" "Local → Repo: $repo_rel" "$mode"
}

do_status() {
  local ret=0
  for entry in "${FILES[@]}"; do
    local pair; pair="$(split_entry "$entry")"
    local local_rel="${pair%%|*}" repo_rel="${pair##*|}"
    local l="$HOME_DIR/$local_rel" r="$REPO_DIR/$repo_rel"
    if [[ -e "$l" && -e "$r" ]]; then
      if ! cmp -s "$l" "$r"; then
        echo "diff -- $local_rel ↔ $repo_rel"
        diff -u "$r" "$l" || true
        ret=1
      fi
    elif [[ -e "$l" && ! -e "$r" ]]; then
      echo "only-in-local: $local_rel"; ret=1
    elif [[ ! -e "$l" && -e "$r" ]]; then
      echo "only-in-repo:  $repo_rel"; ret=1
    else
      echo "missing-both:  $local_rel | $repo_rel"
    fi
  done
  return $ret
}

do_pull() { for rel in "${FILES[@]}"; do copy_repo_to_local "$rel"; done; }

do_push() {
  for rel in "${FILES[@]}"; do copy_local_to_repo "$rel"; done
  log "Push copy complete."

  # Auto-commit via repo's git-ai-commit, then push to remote
  if command -v git >/dev/null 2>&1 && [[ -d "$REPO_DIR/.git" ]]; then
    (
      cd "$REPO_DIR"
      # If nothing changed, bail early (avoid empty commit)
      if git diff --quiet && git diff --cached --quiet; then
        log "No repo changes to commit."
      else
        git add -A
        if [[ -x "$REPO_DIR/.local/bin/git-ai-commit" ]]; then
          "$REPO_DIR/.local/bin/git-ai-commit"
          log "Committed using git-ai-commit."
        else
          warn "git-ai-commit not found or not executable; skipping commit."
        fi
      fi

      # Push if a remote exists
      if git remote get-url origin >/dev/null 2>&1; then
        if git rev-parse --abbrev-ref --symbolic-full-name @{u} >/dev/null 2>&1; then
          git push
        else
          cur_branch="$(git rev-parse --abbrev-ref HEAD)"
          git push -u origin "$cur_branch"
        fi
        log "Pushed to remote."
      else
        warn "No 'origin' remote configured; skipped git push."
      fi
    )
  else
    warn "Not a git repo or git unavailable; skipped commit/push."
  fi
}

# -------------------------------------------------------------------
# Commands
# -------------------------------------------------------------------
cmd="${1:-}"
case "$cmd" in
  status|diff) do_status;;
  pull) do_pull;;
  push) do_push;;
  -h|--help|"") usage;;
  *) echo "Unknown: $cmd" >&2; usage; exit 1;;
esac

# -------------------------------------------------------------------
# PATH update so you can call dot-sync anywhere
# -------------------------------------------------------------------
pathappend() { case ":$PATH:" in *":$1:"*) ;; *) PATH="$PATH:$1";; esac }
pathappend "$REPO_DIR"
